var removeTagAroundSelection = CKEDITOR.tools.addFunction(	function(editor){					//funziona con explorer					//funziona con firefox (ma in caso di selezione con spazi vuoti o su differenti righe la formattazione non viene mantenuta)					//alert(theSelectedText);										var parent = mySelection.getStartElement();										var elementT = CKEDITOR.dom.element.createFromHtml( '<span/>' );					if ( CKEDITOR.env.webkit && theSelectedText == '' ) //per  safari e chrome nel caso di range collassato						{							elementT.setText( 'testo' );							parent.append(elementT);							elementT.breakParent(parent);							editor.getSelection().selectElement(elementT);							selected_ranges = editor.getSelection().getRanges();							var range = selected_ranges[0];							range.deleteContents();							//range.collapse();							//editor.getSelection().selectRanges(selected_ranges);							//elementT.remove(true);													}						else						{						elementT.setText( theSelectedText );						editor.insertElement( elementT );						elementT.breakParent( parent );						editor.getSelection().selectElement(elementT);						selected_ranges = editor.getSelection().getRanges();						var range = selected_ranges[0];						range.moveToElementEditEnd(elementT); 						editor.getSelection().selectRanges(selected_ranges);						//elementT.remove(true); //commentando la rimozione del tag, funziona anche con opera (ma porta tutto su una riga e si impalla) e anche con safari e chrome se il range non è collassato						}										});var insertTagAroundSelection = CKEDITOR.tools.addFunction(	function(editor){					//funziona con explorer, safari e chrome					//funziona con firefox e opera (ma in caso di selezione con spazi vuoti o su differenti righe la formattazione non viene mantenuta)										//alert(theSelectedText);										var element = new CKEDITOR.dom.element(tagOm);					element.setAttribute( 'class', pluginOmissisName );					if ( CKEDITOR.env.webkit && theSelectedText == '' ) //per  safari e chrome nel caso di range collassato						{							element.setText( 'testo' );							editor.insertElement(element);								editor.getSelection().selectElement(element);							selected_ranges = editor.getSelection().getRanges();							var range = selected_ranges[0];							range.deleteContents();												}						else						{						element.setText(theSelectedText);						editor.insertElement(element);						editor.getSelection().selectElement(element);						selected_ranges = editor.getSelection().getRanges();						var range = selected_ranges[0];						range.moveToElementEditEnd(element);						editor.getSelection().selectRanges(selected_ranges);						}					});var omissisState = CKEDITOR.tools.addFunction(	function(editor)					{					var style = new CKEDITOR.style( { element: tagOm, attributes: { 'class': pluginOmissisName} } );						editor.attachStyleStateChange( style, function(state )						{						if ( state == CKEDITOR.TRISTATE_ON )							{							editor.getCommand(pluginOmissisName).setState(CKEDITOR.TRISTATE_ON);							}						else 							{							editor.getCommand(pluginOmissisName).setState(CKEDITOR.TRISTATE_OFF);							}						});					});var omissis = CKEDITOR.tools.addFunction(    function(editor)				{					mySelection = editor.getSelection();					if (CKEDITOR.env.ie) {						mySelection.unlock(true);						theSelectedText = mySelection.getNative().createRange().text;					} else {						theSelectedText = mySelection.getNative();					}				// Se richiamo la funzione omissis selezionando due righe di un elenco puntato o numerato, le due righe vengono collassate.				// Quindi con il codice che segue si impedisce (in questo caso) di richiamare la funzione omissis.					var ancestor = mySelection.getCommonAncestor();						//alert("TIPO NODO: "+ ancestor.type + "; tipi nodo: Text node type("+ CKEDITOR.NODE_TEXT +") Element node type(" + CKEDITOR.NODE_ELEMENT +") Document node type(" + CKEDITOR.NODE_DOCUMENT +") Comment node type(" + CKEDITOR.NODE_COMMENT +")" );					// se il nodo antenato è di tipo elemento ed è un elemento lista esco					if(ancestor.type == CKEDITOR.NODE_ELEMENT){						var ancestorName = ancestor.getName()						if(ancestorName =='ol' || ancestorName =='ul'){							alert("negli elenchi, è possibile utilizzare la funzione omissis solo su una riga per volta");							return						}					}																									if (editor.getCommand(pluginOmissisName).state == CKEDITOR.TRISTATE_ON)					{						var selected_ranges = mySelection.getRanges();						var numeroRanges = selected_ranges.length;						if (numeroRanges>1){						alert("è possibile toglere l'omissis solo su selezioni contigue");						}						else						{						CKEDITOR.tools.callFunction(removeTagAroundSelection, editor);						}					}					else					{						var selected_ranges = mySelection.getRanges();						var numeroRanges = selected_ranges.length;						if (numeroRanges>1){						alert("è possibile inserire l'omissis solo su selezioni contigue");						}						else						{						CKEDITOR.tools.callFunction(insertTagAroundSelection, editor);						}					}				});CKEDITOR.plugins.add('omissis',{    init: function(editor)    {        tagOm = editor.config.tagOmissis;		pluginOmissisName = 'omissis';		pluginOmissisNameState = 'omissistate';        editor.addCommand( pluginOmissisName,			{				exec: function(editor)				{				CKEDITOR.tools.callFunction( omissis, editor);				}			});		editor.addCommand( pluginOmissisNameState,			{				exec: function(editor)				{				CKEDITOR.tools.callFunction( omissisState, editor);				}			});			editor.ui.add( 'Omissis', CKEDITOR.UI_BUTTON,            {                label: 'Inserisci un omissis',                icon: this.path + pluginOmissisName + '.gif',                command: pluginOmissisName            });		editor.execCommand(pluginOmissisNameState);    }});